# 509. 斐波那契数: 

[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

 

示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
 

提示：

0 <= n <= 30
```
## 方法 1: 直接使用暴力递归

### 思路

* 根据题意，`n=0` 与 `n=1` 时直接返回对应的值
* 当 `n>1` 时，`f(n) = f(n - 1) + f(n - 2)`

```python
class Solution:
    def fib(self, n: int) -> int:
        # 1. 直接用暴力递归
        if n <= 1:
            return n
        return f(n - 1) + f(n - 2)

        # 或直接简写为
        return n if n <= 1 else self.fib(n - 1) + self.fib(n - 2)
```

### 复杂度分析

* 时间复杂度：O(2^n)
    * 指数级增长，是非常恐怖的增速
* 空间复杂度：O(1)

## 方法 2: 使用递归 + 缓存（记忆化搜索）

### 思路

* 方法 1，直接使用递归，在数字较小时，还可能，但尤其这种方法在时间复杂度上是 **指数增长** 的
* 所以要想办法 **降低时间复杂度**，一种可以行的方法，就是 **用空间换时间**
    * 增加一个哈希表，用来存储已经计算过的值
* 递归的方法，是 **自顶向下** ，从 n 开始一直探到最下面的 `0` 与 `1`

```python
class Solution:
    def fib(self, n: int) -> int:
        # 1. 递归 + 缓存
        memo = {0: 0, 1: 1}
        if n not in memo:  # 如果 n 还没有被计算过
            memo[n] = self.fib(n - 1) + self.fib(n - 2)
        return memo[n]
```

### 复杂度分析

* 时间复杂度：O(n)
* 空间复杂度：O(n)

## 方法 3: 使用动态规划 (递推)

### 思路

* 与方法 2 **自顶向下** 相反，这里 **自底向上**
* 已经知道 0, 1 对应的值，又知道具体的对应规则，那就可以依次推出 `2, 3, 4, ...` 对应的值
* 这种递推，直接使用 **循环** 即可以得出。

```python
class Solution:
    def fib(self, n: int) -> int:
        # 2. 使用动态规划，自底向上，使用循环
        dp = {0: 0, 1: 1}
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]

        return dp[n]
```

### 复杂度分析

* 时间复杂度：O(n)
* 空间复杂度：O(n)


## 方法 4: 使用递推（动态规划）

### 思路

* 思路与 方法 3 相同，在本题，我们只需要返回 n 所对应的值，对于中间的状态，则无需开个数组存储起来
    * 也即，空间上还可以进行优化
* 直接使用两个变量分别记录前面一个 `p1`，及前面第 2 个 `p2`

```python
class Solution:
    def fib(self, n: int) -> int:
        # 3. 使用动态规划，并对空间进行压缩优化
        if n <= 1:
            return n

        p1, p2 = 0, 1
        for i in range(2, n + 1):
            temp = p1 + p2
            p1 = p2
            p2 = temp
        return p2
```

### 复杂度分析

* 时间复杂度：O()
* 空间复杂度：O()
